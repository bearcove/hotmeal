//! WASM client for hotmeal
//!
//! Applies DOM patches in the browser using web-sys.
//! This is used to test that patches generated by hotmeal
//! correctly transform the DOM when applied in a real browser.
//!
//! ## Chawathe Semantics
//!
//! Patches follow Chawathe edit script semantics: Insert and Move operations
//! do NOT shift siblings. Instead, they displace whatever node occupies the
//! target position into a numbered slot. The DOM's `replaceChild` method
//! provides atomic displacement, returning the removed node for storage.
//!
//! ## Mount Points
//!
//! All patch application functions come in two flavors:
//! - Body-based (e.g. `apply_patches`) — uses `document.body` as the root
//! - Mount-point-based (e.g. `apply_patches_on`) — uses a CSS selector to find the root element
//!
//! The mount-point variants enable applying patches to a subtree of the page,
//! which is essential for live-reload systems where hotmeal manages only part
//! of the document.

use hotmeal::{InsertContent, NodeId, StrTendril, parse};
#[cfg(target_arch = "wasm32")]
use hotmeal_server::LiveReloadEvent;
use smallvec::SmallVec;
use tracing::{debug, trace};
use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, Node};

/// Initialize tracing subscriber for WASM (sends output to browser console).
/// Call this once at startup.
#[wasm_bindgen]
pub fn init_tracing() {
    let mut config = wasm_tracing::WasmLayerConfig::default();
    config.set_max_level(tracing::Level::TRACE);
    let _ = wasm_tracing::set_as_global_default_with_config(config);
}

// Re-export patch types for reference
pub use hotmeal::{NodePath, NodeRef, Patch, PropChange, PropKey};

/// Compute diff between two HTML documents and return patches as JSON.
/// This allows computing diffs in the browser for fuzzing tests.
#[wasm_bindgen]
pub fn diff_html(old_html: &str, new_html: &str) -> Result<String, JsValue> {
    let old_tendril = StrTendril::from(old_html);
    let new_tendril = StrTendril::from(new_html);
    let patches = hotmeal::diff_html(&old_tendril, &new_tendril)
        .map_err(|e| JsValue::from_str(&format!("diff failed: {e}")))?;

    let json = facet_json::to_string(&patches)
        .map_err(|e| JsValue::from_str(&format!("serialize failed: {e}")))?;

    Ok(json)
}

/// Compute diff between two HTML documents and return patches directly.
/// Returns owned patches for use with apply_patches.
pub fn diff_html_patches(old_html: &str, new_html: &str) -> Result<Vec<Patch<'static>>, JsValue> {
    let old_tendril = StrTendril::from(old_html);
    let new_tendril = StrTendril::from(new_html);
    let patches = hotmeal::diff_html(&old_tendril, &new_tendril)
        .map_err(|e| JsValue::from_str(&format!("diff failed: {e}")))?;

    Ok(patches.into_iter().map(|p| p.into_owned()).collect())
}

/// Slots for detached nodes during patch application.
/// In Chawathe's model, INSERT doesn't shift - it displaces the occupant to a slot.
///
/// Use this with `apply_patches_with_slots` when applying patches incrementally.
pub struct Slots {
    nodes: Vec<Option<Node>>,
}

impl Slots {
    pub fn new() -> Self {
        Self { nodes: Vec::new() }
    }

    pub fn store(&mut self, slot: u32, node: Node) {
        let idx = slot as usize;
        if idx >= self.nodes.len() {
            self.nodes.resize(idx + 1, None);
        }
        self.nodes[idx] = Some(node);
    }

    pub fn take(&mut self, slot: u32) -> Option<Node> {
        let idx = slot as usize;
        if idx < self.nodes.len() {
            self.nodes[idx].take()
        } else {
            None
        }
    }

    pub fn get(&self, slot: u32) -> Option<&Node> {
        let idx = slot as usize;
        self.nodes.get(idx).and_then(|n| n.as_ref())
    }
}

impl Default for Slots {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================================================
// Body-based public API (convenience wrappers)
// ============================================================================

/// Apply a list of patches (JSON) to the document body.
/// Returns the number of patches applied, or an error message.
#[wasm_bindgen]
pub fn apply_patches_json(patches_json: &str) -> Result<usize, JsValue> {
    let patches: Vec<Patch> = facet_json::from_str(patches_json)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse patches: {e}")))?;

    apply_patches(&patches)
}

/// Apply patches to the document body (high-level API with internal slots).
pub fn apply_patches(patches: &[Patch]) -> Result<usize, JsValue> {
    let mut slots = Slots::new();
    apply_patches_with_slots(patches, &mut slots)
}

/// Apply patches to the document body with external slot storage.
/// Use this when applying patches incrementally and need to preserve slot state.
pub fn apply_patches_with_slots(patches: &[Patch], slots: &mut Slots) -> Result<usize, JsValue> {
    let document = get_document()?;
    let body: Node = document
        .body()
        .ok_or_else(|| JsValue::from_str("no body"))?
        .into();
    apply_patches_with_slots_on_root(&document, &body, patches, slots)
}

/// Apply postcard-serialized patches to document body.
#[wasm_bindgen]
pub fn apply_patches_postcard(patches_blob: &[u8]) -> Result<usize, JsValue> {
    let patches: Vec<Patch<'static>> = facet_postcard::from_slice(patches_blob)
        .map_err(|e| JsValue::from_str(&format!("Failed to deserialize patches: {e}")))?;
    apply_patches(&patches)
}

// ============================================================================
// Mount-point-based public API
// ============================================================================

/// Apply patches to a mount-point element identified by CSS selector.
pub fn apply_patches_on(patches: &[Patch], mount_selector: &str) -> Result<usize, JsValue> {
    let mut slots = Slots::new();
    apply_patches_with_slots_on(patches, &mut slots, mount_selector)
}

/// Apply patches to a mount-point element with external slot storage.
pub fn apply_patches_with_slots_on(
    patches: &[Patch],
    slots: &mut Slots,
    mount_selector: &str,
) -> Result<usize, JsValue> {
    let document = get_document()?;
    let root = resolve_mount_point(&document, mount_selector)?;
    apply_patches_with_slots_on_root(&document, &root, patches, slots)
}

/// Apply postcard-serialized patches to a mount-point element.
#[wasm_bindgen]
pub fn apply_patches_postcard_on(
    patches_blob: &[u8],
    mount_selector: &str,
) -> Result<usize, JsValue> {
    let patches: Vec<Patch<'static>> = facet_postcard::from_slice(patches_blob)
        .map_err(|e| JsValue::from_str(&format!("Failed to deserialize patches: {e}")))?;
    apply_patches_on(&patches, mount_selector)
}

// ============================================================================
// Live-reload roam RPC client (wasm32 only)
// ============================================================================

#[cfg(target_arch = "wasm32")]
mod live_reload {
    use super::*;
    use hotmeal_server::{LiveReloadBrowser, LiveReloadBrowserDispatcher, LiveReloadServiceClient};
    use roam_session::HandshakeConfig;
    use roam_websocket::WsTransport;

    /// Browser-side implementation of the `LiveReloadBrowser` service.
    ///
    /// The server calls `on_event()` on this whenever content changes for
    /// the subscribed route.
    #[derive(Clone)]
    struct LiveReloadBrowserImpl {
        mount_selector: String,
    }

    impl LiveReloadBrowser for LiveReloadBrowserImpl {
        async fn on_event(&self, _cx: &roam::Context, event: LiveReloadEvent) {
            if let Err(e) = handle_live_reload_event(&event, &self.mount_selector) {
                log(&format!("[hotmeal-wasm] error handling event: {e:?}"));
            }
        }
    }

    fn handle_live_reload_event(
        event: &LiveReloadEvent,
        mount_selector: &str,
    ) -> Result<(), JsValue> {
        match event {
            LiveReloadEvent::Reload => {
                log("[hotmeal-wasm] full reload requested");
                let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
                window.location().reload()?;
            }
            LiveReloadEvent::Patches {
                route: _,
                patches_blob,
            } => {
                let count = apply_patches_postcard_on(patches_blob, mount_selector)?;
                log(&format!("[hotmeal-wasm] applied {count} patches"));
            }
            LiveReloadEvent::HeadChanged { route: _ } => {
                log("[hotmeal-wasm] head changed, reloading");
                let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
                window.location().reload()?;
            }
        }
        Ok(())
    }

    /// Start a live-reload connection via roam RPC over WebSocket.
    ///
    /// Connects to the server at `ws_url`, subscribes to events for the current
    /// browser route, and applies patches to the element matched by `mount_selector`.
    /// Handles reconnection with exponential backoff.
    #[wasm_bindgen]
    pub fn start_live_reload(ws_url: &str, mount_selector: &str) -> Result<(), JsValue> {
        let ws_url = ws_url.to_owned();
        let mount_selector = mount_selector.to_owned();

        wasm_bindgen_futures::spawn_local(async move {
            live_reload_loop(&ws_url, &mount_selector).await;
        });

        Ok(())
    }

    async fn live_reload_loop(ws_url: &str, mount_selector: &str) {
        let mut backoff_ms: u32 = 100;
        let max_backoff_ms: u32 = 5000;

        loop {
            log(&format!("[hotmeal-wasm] connecting to {ws_url}"));

            match live_reload_session(ws_url, mount_selector).await {
                Ok(()) => {
                    log("[hotmeal-wasm] session ended");
                    backoff_ms = 100;
                }
                Err(e) => {
                    log(&format!("[hotmeal-wasm] session error: {e:?}"));
                }
            }

            log("[hotmeal-wasm] reconnecting...");
            roam_session::runtime::sleep(std::time::Duration::from_millis(backoff_ms as u64)).await;
            backoff_ms = (backoff_ms * 2).min(max_backoff_ms);
        }
    }

    async fn live_reload_session(
        ws_url: &str,
        mount_selector: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let transport = WsTransport::connect(ws_url).await?;

        let dispatcher = LiveReloadBrowserDispatcher::new(LiveReloadBrowserImpl {
            mount_selector: mount_selector.to_owned(),
        });
        let config = HandshakeConfig::default();
        let (handle, _incoming, driver) =
            roam_session::accept_framed(transport, config, dispatcher).await?;

        let client = LiveReloadServiceClient::new(handle);

        // Spawn the driver — it processes incoming/outgoing RPC messages.
        // When the connection closes, driver.run() returns and signals via the oneshot.
        let (done_tx, done_rx) = futures_channel::oneshot::channel::<()>();
        wasm_bindgen_futures::spawn_local(async move {
            if let Err(e) = driver.run().await {
                log(&format!("[hotmeal-wasm] driver error: {e}"));
            }
            let _ = done_tx.send(());
        });

        log("[hotmeal-wasm] roam session established");

        // Subscribe for the current browser route
        let route = web_sys::window()
            .and_then(|w| w.location().pathname().ok())
            .unwrap_or_else(|| "/".to_owned());

        log(&format!("[hotmeal-wasm] subscribing to route: {route}"));
        client.subscribe(route).await?;
        log("[hotmeal-wasm] subscribed, waiting for events");

        // Wait for the driver to finish (connection closed by server or network)
        let _ = done_rx.await;

        Ok(())
    }
}

// ============================================================================
// Internal implementation (root-parameterized)
// ============================================================================

fn get_document() -> Result<Document, JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))
}

fn resolve_mount_point(doc: &Document, selector: &str) -> Result<Node, JsValue> {
    // Special-case "body" selector for convenience
    if selector == "body" {
        return doc
            .body()
            .map(|b| b.into())
            .ok_or_else(|| JsValue::from_str("no body"));
    }

    doc.query_selector(selector)
        .map_err(|e| JsValue::from_str(&format!("invalid selector {selector:?}: {e:?}")))?
        .map(|el| el.into())
        .ok_or_else(|| JsValue::from_str(&format!("mount point not found: {selector}")))
}

/// Core patch application logic. Operates on an arbitrary root node.
fn apply_patches_with_slots_on_root(
    doc: &Document,
    root: &Node,
    patches: &[Patch],
    slots: &mut Slots,
) -> Result<usize, JsValue> {
    let count = patches.len();
    log(&format!("[hotmeal-wasm] applying {} patches", count));

    for (i, patch) in patches.iter().enumerate() {
        log(&format!("[hotmeal-wasm] patch {}: {:?}", i, patch));
        apply_patch(doc, root, patch, slots).map_err(|e| {
            let msg = e
                .as_string()
                .or_else(|| {
                    js_sys::Reflect::get(&e, &JsValue::from_str("message"))
                        .ok()
                        .and_then(|v| v.as_string())
                })
                .or_else(|| js_sys::JSON::stringify(&e).ok().and_then(|v| v.as_string()))
                .unwrap_or_else(|| format!("{:?}", e));
            JsValue::from_str(&format!("patch {}: {}", i, msg))
        })?;
    }

    Ok(count)
}

/// Get the slot root node. Slot 0 uses the provided `root`, higher slots use stored nodes.
fn get_slot_root(root: &Node, slot: u32, slots: &Slots) -> Result<Node, JsValue> {
    if slot == 0 {
        Ok(root.clone())
    } else {
        slots
            .get(slot)
            .cloned()
            .ok_or_else(|| JsValue::from_str(&format!("slot {} is empty", slot)))
    }
}

fn apply_patch(
    doc: &Document,
    root: &Node,
    patch: &Patch,
    slots: &mut Slots,
) -> Result<(), JsValue> {
    debug!(?patch, "applying patch");
    match patch {
        Patch::SetText { path, text } => {
            let node = find_node(root, path, slots)?;
            node.set_text_content(Some(text));
        }

        Patch::SetAttribute { path, name, value } => {
            let el = find_element(root, path, slots)?;
            let attr_name = match name.prefix.as_ref().filter(|p| !p.is_empty()) {
                Some(prefix) => format!("{}:{}", prefix, name.local),
                None => name.local.to_string(),
            };
            el.set_attribute(&attr_name, value)?;
        }

        Patch::RemoveAttribute { path, name } => {
            let el = find_element(root, path, slots)?;
            let attr_name = match name.prefix.as_ref().filter(|p| !p.is_empty()) {
                Some(prefix) => format!("{}:{}", prefix, name.local),
                None => name.local.to_string(),
            };
            el.remove_attribute(&attr_name)?;
        }

        Patch::Remove { node } => {
            let NodeRef(path) = node;
            let slot = path.0[0];
            if slot == 0 {
                let rel_path = NodePath(SmallVec::from_slice(&path.0[1..]));
                let target = navigate_within_node(root, &rel_path)?;
                if let Some(parent) = target.parent_node() {
                    let empty_text: Node = doc.create_text_node("").into();
                    parent.replace_child(&empty_text, &target)?;
                }
            } else if path.0.len() == 1 {
                slots.take(slot);
            } else {
                let slot_root = get_slot_root(root, slot, slots)?;
                let rel_path = NodePath(SmallVec::from_slice(&path.0[1..]));
                let target = navigate_within_node(&slot_root, &rel_path)?;
                if let Some(parent) = target.parent_node() {
                    let empty_text = doc.create_text_node("");
                    parent.replace_child(&empty_text, &target)?;
                }
            }
        }

        Patch::InsertElement {
            at,
            tag,
            attrs,
            children,
            detach_to_slot,
        } => {
            let NodeRef(path) = at;
            if path.0.len() < 2 {
                return Err(JsValue::from_str("InsertElement: path too short"));
            }
            let slot = path.0[0];
            let position = path.0[path.0.len() - 1];

            let slot_root = get_slot_root(root, slot, slots)?;

            let parent_path = NodePath(SmallVec::from_slice(&path.0[1..path.0.len() - 1]));
            let parent_node = if parent_path.0.is_empty() {
                slot_root
            } else {
                navigate_within_node(&slot_root, &parent_path)?
            };

            let parent_el = parent_node
                .dyn_ref::<Element>()
                .ok_or_else(|| JsValue::from_str("parent is not an element"))?
                .clone();

            let new_node: Node = match create_element_with_attrs(doc, tag, attrs) {
                Ok(el) => {
                    for child in children {
                        let child_node = create_insert_content(doc, child)?;
                        el.append_child(&child_node)?;
                    }
                    el.into()
                }
                Err(_) => create_element_via_html(doc, tag, attrs, children)?,
            };

            insert_at_position(
                doc,
                &parent_el,
                &new_node,
                position as usize,
                *detach_to_slot,
                slots,
            )?;
        }

        Patch::InsertText {
            at,
            text,
            detach_to_slot,
        } => {
            let NodeRef(path) = at;
            if path.0.len() < 2 {
                return Err(JsValue::from_str("InsertText: path too short"));
            }
            let slot = path.0[0];
            let position = path.0[path.0.len() - 1];

            let slot_root = get_slot_root(root, slot, slots)?;

            let parent_path = NodePath(SmallVec::from_slice(&path.0[1..path.0.len() - 1]));
            let parent_node = if parent_path.0.is_empty() {
                slot_root
            } else {
                navigate_within_node(&slot_root, &parent_path)?
            };

            let parent_el = parent_node
                .dyn_ref::<Element>()
                .ok_or_else(|| JsValue::from_str("parent is not an element"))?
                .clone();

            let text_node = doc.create_text_node(text);

            insert_at_position(
                doc,
                &parent_el,
                &text_node.into(),
                position as usize,
                *detach_to_slot,
                slots,
            )?;
        }

        Patch::InsertComment {
            at,
            text,
            detach_to_slot,
        } => {
            let NodeRef(path) = at;
            if path.0.len() < 2 {
                return Err(JsValue::from_str("InsertComment: path too short"));
            }
            let slot = path.0[0];
            let position = path.0[path.0.len() - 1];

            let slot_root = get_slot_root(root, slot, slots)?;

            let parent_path = NodePath(SmallVec::from_slice(&path.0[1..path.0.len() - 1]));
            let parent_node = if parent_path.0.is_empty() {
                slot_root
            } else {
                navigate_within_node(&slot_root, &parent_path)?
            };

            let parent_el = parent_node
                .dyn_ref::<Element>()
                .ok_or_else(|| JsValue::from_str("parent is not an element"))?
                .clone();

            let comment_node = doc.create_comment(text);

            insert_at_position(
                doc,
                &parent_el,
                &comment_node.into(),
                position as usize,
                *detach_to_slot,
                slots,
            )?;
        }

        Patch::UpdateProps { path, changes } => {
            let node = find_node(root, path, slots)?;

            if let Some(text_change) = changes.iter().find(|c| matches!(c.name, PropKey::Text))
                && let Some(v) = &text_change.value
            {
                node.set_text_content(Some(v));
            }

            if let Some(el) = node.dyn_ref::<Element>() {
                let existing: std::collections::HashMap<String, String> =
                    (0..el.attributes().length())
                        .filter_map(|i| el.attributes().item(i).map(|a| (a.name(), a.value())))
                        .collect();

                for attr_name in existing.keys() {
                    el.remove_attribute(attr_name)?;
                }

                for change in changes {
                    if let PropKey::Attr(ref qual_name) = change.name {
                        let attr_name = if let Some(ref prefix) = qual_name.prefix {
                            format!("{}:{}", prefix, qual_name.local)
                        } else {
                            qual_name.local.to_string()
                        };
                        let value = match &change.value {
                            Some(v) => v.as_ref().to_string(),
                            None => existing.get(&attr_name).cloned().unwrap_or_default(),
                        };
                        el.set_attribute(&attr_name, &value)?;
                    }
                }
            }
        }

        Patch::Move {
            from,
            to,
            detach_to_slot,
        } => {
            let from_path = &from.0;
            let to_path = &to.0;

            let node = if from_path.0.len() == 1 {
                let slot = from_path.0[0];
                slots
                    .take(slot)
                    .ok_or_else(|| JsValue::from_str(&format!("slot {} is empty", slot)))?
            } else {
                let node = find_node(root, from_path, slots)?;
                if let Some(parent) = node.parent_node() {
                    let empty_text = doc.create_text_node("");
                    parent.replace_child(&empty_text, &node)?;
                }
                node
            };

            if to_path.0.len() < 2 {
                return Err(JsValue::from_str("Move: target path too short"));
            }
            let parent_path = NodePath(SmallVec::from_slice(&to_path.0[..to_path.0.len() - 1]));
            let target_idx = to_path.0[to_path.0.len() - 1];

            let parent_node = find_node(root, &parent_path, slots)?;
            let parent_el = parent_node
                .dyn_ref::<Element>()
                .ok_or_else(|| JsValue::from_str("Move: parent is not an element"))?;

            insert_at_position(
                doc,
                parent_el,
                &node,
                target_idx as usize,
                *detach_to_slot,
                slots,
            )?;
        }

        Patch::OpaqueChanged { path, content } => {
            let el = find_element(root, path, slots)?;
            let detail = js_sys::Object::new();
            js_sys::Reflect::set(
                &detail,
                &JsValue::from_str("content"),
                &JsValue::from_str(content),
            )?;
            let init = web_sys::CustomEventInit::new();
            init.set_bubbles(true);
            init.set_detail(&detail);
            let event =
                web_sys::CustomEvent::new_with_event_init_dict("hotmeal:opaque-changed", &init)?;
            el.dispatch_event(&event)?;
        }
    }

    Ok(())
}

/// Insert a node at a position within a parent, using Chawathe displacement semantics.
/// If there's a node at the position, it gets replaced (and optionally stored in a slot).
fn insert_at_position(
    doc: &Document,
    parent: &Element,
    node: &Node,
    position: usize,
    detach_to_slot: Option<u32>,
    slots: &mut Slots,
) -> Result<(), JsValue> {
    let children = parent.child_nodes();
    let current_len = children.length() as usize;
    let pos = position as u32;

    trace!(
        parent_tag = parent.tag_name(),
        position,
        current_len,
        ?detach_to_slot,
        "insert_at_position"
    );

    if position < current_len {
        let existing = children.item(pos).unwrap();
        trace!(
            existing_node_type = existing.node_type(),
            existing_text = ?existing.text_content(),
            "replacing existing node"
        );
        let replaced = parent.replace_child(node, &existing)?;
        if let Some(slot) = detach_to_slot {
            trace!(slot, "storing replaced node in slot");
            slots.store(slot, replaced);
        }
    } else {
        trace!(
            growing_from = current_len,
            growing_to = position,
            "growing with placeholders"
        );
        for _ in current_len..position {
            let placeholder = doc.create_text_node("");
            parent.append_child(&placeholder)?;
        }
        parent.append_child(node)?;
    }

    Ok(())
}

/// Try to create an element with attributes using the DOM API.
/// Returns Err if any attribute name is invalid for setAttribute.
fn create_element_with_attrs(
    doc: &Document,
    tag: &str,
    attrs: &[hotmeal::AttrPair],
) -> Result<Element, JsValue> {
    let el = doc.create_element(tag)?;
    for attr in attrs {
        let attr_name = match attr.name.prefix.as_ref().filter(|p| !p.is_empty()) {
            Some(prefix) => format!("{}:{}", prefix, attr.name.local),
            None => attr.name.local.to_string(),
        };
        el.set_attribute(&attr_name, &attr.value)?;
    }
    Ok(el)
}

/// Create an element via innerHTML when setAttribute fails.
/// This handles exotic attribute names that the HTML parser accepts but the DOM API rejects.
fn create_element_via_html(
    doc: &Document,
    tag: &str,
    attrs: &[hotmeal::AttrPair],
    children: &[InsertContent],
) -> Result<Node, JsValue> {
    use web_sys::HtmlTemplateElement;

    let mut html = format!("<{}", tag);
    for attr in attrs {
        let attr_name = match attr.name.prefix.as_ref().filter(|p| !p.is_empty()) {
            Some(prefix) => format!("{}:{}", prefix, attr.name.local),
            None => attr.name.local.to_string(),
        };
        let escaped_value = attr
            .value
            .replace('&', "&amp;")
            .replace('"', "&quot;")
            .replace('<', "&lt;")
            .replace('>', "&gt;");
        html.push_str(&format!(" {}=\"{}\"", attr_name, escaped_value));
    }
    html.push('>');

    for child in children {
        serialize_insert_content(&mut html, child);
    }

    html.push_str(&format!("</{}>", tag));

    let template = doc
        .create_element("template")?
        .dyn_into::<HtmlTemplateElement>()
        .map_err(|_| JsValue::from_str("failed to create template element"))?;
    template.set_inner_html(&html);

    template
        .content()
        .first_child()
        .ok_or_else(|| JsValue::from_str("template content is empty"))
}

/// Serialize InsertContent to HTML string
fn serialize_insert_content(out: &mut String, content: &InsertContent) {
    match content {
        InsertContent::Element {
            tag,
            attrs,
            children,
        } => {
            out.push('<');
            out.push_str(tag);
            for attr in attrs {
                let attr_name = match attr.name.prefix.as_ref().filter(|p| !p.is_empty()) {
                    Some(prefix) => format!("{}:{}", prefix, attr.name.local),
                    None => attr.name.local.to_string(),
                };
                let escaped_value = attr
                    .value
                    .replace('&', "&amp;")
                    .replace('"', "&quot;")
                    .replace('<', "&lt;")
                    .replace('>', "&gt;");
                out.push_str(&format!(" {}=\"{}\"", attr_name, escaped_value));
            }
            out.push('>');
            for child in children {
                serialize_insert_content(out, child);
            }
            out.push_str("</");
            out.push_str(tag);
            out.push('>');
        }
        InsertContent::Text(text) => {
            out.push_str(&text.replace('&', "&amp;").replace('<', "&lt;"));
        }
        InsertContent::Comment(text) => {
            out.push_str("<!--");
            out.push_str(text);
            out.push_str("-->");
        }
    }
}

/// Create a DOM node from InsertContent.
fn create_insert_content(doc: &Document, content: &InsertContent) -> Result<Node, JsValue> {
    match content {
        InsertContent::Element {
            tag,
            attrs,
            children,
        } => match create_element_with_attrs(doc, tag, attrs) {
            Ok(el) => {
                for child in children {
                    let child_node = create_insert_content(doc, child)?;
                    el.append_child(&child_node)?;
                }
                Ok(el.into())
            }
            Err(_) => create_element_via_html(doc, tag, attrs, children),
        },
        InsertContent::Text(text) => Ok(doc.create_text_node(text).into()),
        InsertContent::Comment(text) => Ok(doc.create_comment(text).into()),
    }
}

/// Navigate a relative path within a node (for slot-relative paths).
fn navigate_within_node(root: &Node, path: &NodePath) -> Result<Node, JsValue> {
    let mut current = root.clone();
    for &idx in &path.0 {
        let children = current.child_nodes();
        current = children
            .item(idx)
            .ok_or_else(|| JsValue::from_str(&format!("relative path child {} not found", idx)))?;
    }
    Ok(current)
}

/// Find a node by slot-based path.
/// Path format: [slot, child1, child2, ...] where slot 0 = root
fn find_node(root: &Node, path: &NodePath, slots: &Slots) -> Result<Node, JsValue> {
    if path.0.is_empty() {
        return Err(JsValue::from_str("empty path"));
    }

    let slot = path.0[0];
    trace!(?path, slot, "find_node");

    let slot_root = get_slot_root(root, slot, slots)?;

    let mut current = slot_root;
    for &idx in &path.0[1..] {
        let children = current.child_nodes();
        let num_children = children.length();
        trace!(idx, num_children, "navigating to child");
        current = children.item(idx).ok_or_else(|| {
            JsValue::from_str(&format!(
                "child {} not found (parent has {} children)",
                idx, num_children
            ))
        })?;
        trace!(
            node_type = current.node_type(),
            node_name = current.node_name(),
            "found node"
        );
    }

    Ok(current)
}

/// Find an element by DOM path.
fn find_element(root: &Node, path: &NodePath, slots: &Slots) -> Result<Element, JsValue> {
    let node = find_node(root, path, slots)?;
    node.dyn_into::<Element>()
        .map_err(|_| JsValue::from_str("node is not an element"))
}

/// Log a message to the browser console.
#[wasm_bindgen]
pub fn log(msg: &str) {
    web_sys::console::log_1(&JsValue::from_str(msg));
}

/// Get the innerHTML of the body element.
#[wasm_bindgen]
pub fn get_body_inner_html() -> Result<String, JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;
    let body = document
        .body()
        .ok_or_else(|| JsValue::from_str("no body"))?;

    Ok(body.inner_html())
}

/// Set the innerHTML of the body element.
#[wasm_bindgen]
pub fn set_body_inner_html(html: &str) -> Result<(), JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;
    let body = document
        .body()
        .ok_or_else(|| JsValue::from_str("no body"))?;

    body.set_inner_html(html);
    Ok(())
}

/// Dump the browser DOM structure as a string (for debugging).
#[wasm_bindgen]
pub fn dump_browser_dom() -> Result<String, JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;
    let body = document
        .body()
        .ok_or_else(|| JsValue::from_str("no body"))?;

    fn dump_node(node: &Node, indent: usize) -> String {
        let prefix = "  ".repeat(indent);
        let mut result = String::new();

        let node_type = node.node_type();
        match node_type {
            Node::ELEMENT_NODE => {
                let tag = node.node_name();
                result.push_str(&format!("{}Element({})\n", prefix, tag));
            }
            Node::TEXT_NODE => {
                let text = node.text_content().unwrap_or_default();
                let escaped = text.replace('\n', "\\n").replace(' ', "·");
                result.push_str(&format!("{}Text({:?})\n", prefix, escaped));
            }
            _ => {
                result.push_str(&format!("{}Node(type={})\n", prefix, node_type));
            }
        }

        let children = node.child_nodes();
        for i in 0..children.length() {
            if let Some(child) = children.get(i) {
                result.push_str(&dump_node(&child, indent + 1));
            }
        }
        result
    }

    Ok(dump_node(&body.into(), 0))
}

/// Dump the Rust-parsed HTML structure as a string (for debugging).
/// Uses arena_dom which is what diff_html uses.
#[wasm_bindgen]
pub fn dump_rust_parsed(html: &str) -> Result<String, JsValue> {
    use hotmeal::{self, NodeKind};

    let full_html = StrTendril::from(format!("<html><body>{}</body></html>", html));
    let doc = parse(&full_html);

    fn dump_node(doc: &hotmeal::Document, node_id: NodeId, indent: usize) -> String {
        let prefix = "  ".repeat(indent);
        let node = doc.get(node_id);
        let mut result = match &node.kind {
            NodeKind::Document => format!("{}Document\n", prefix),
            NodeKind::Element(elem) => {
                format!("{}Element({})\n", prefix, elem.tag.as_ref().to_uppercase())
            }
            NodeKind::Text(t) => {
                let escaped = t.as_ref().replace('\n', "\\n").replace(' ', "·");
                format!("{}Text({:?})\n", prefix, escaped)
            }
            NodeKind::Comment(c) => {
                format!("{}Comment({:?})\n", prefix, c.as_ref())
            }
        };
        for child_id in node_id.children(&doc.arena) {
            result.push_str(&dump_node(doc, child_id, indent + 1));
        }
        result
    }

    fn find_body(doc: &hotmeal::Document, node_id: NodeId) -> Option<NodeId> {
        let node = doc.get(node_id);
        if let NodeKind::Element(elem) = &node.kind
            && elem.tag.as_ref().eq_ignore_ascii_case("body")
        {
            return Some(node_id);
        }
        for child_id in node_id.children(&doc.arena) {
            if let Some(body_id) = find_body(doc, child_id) {
                return Some(body_id);
            }
        }
        None
    }

    let body_id = find_body(&doc, doc.root)
        .ok_or_else(|| JsValue::from_str("body element not found in parsed HTML"))?;

    Ok(dump_node(&doc, body_id, 0))
}
