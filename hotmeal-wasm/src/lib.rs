//! WASM client for hotmeal
//!
//! Applies DOM patches in the browser using web-sys.
//! This is used to test that patches generated by hotmeal
//! correctly transform the DOM when applied in a real browser.
//!
//! ## Chawathe Semantics
//!
//! Patches follow Chawathe edit script semantics: Insert and Move operations
//! do NOT shift siblings. Instead, they displace whatever node occupies the
//! target position into a numbered slot. The DOM's `replaceChild` method
//! provides atomic displacement, returning the removed node for storage.

use hotmeal::{InsertContent, NodeId, PropKey, parse};
use tracing::{debug, trace};
use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, Node};

/// Initialize tracing subscriber for WASM (sends output to browser console).
/// Call this once at startup.
#[wasm_bindgen]
pub fn init_tracing() {
    let mut config = wasm_tracing::WasmLayerConfig::default();
    config.set_max_level(tracing::Level::TRACE);
    let _ = wasm_tracing::set_as_global_default_with_config(config);
}

// Re-export patch types for reference
pub use hotmeal::{NodePath, NodeRef, Patch, PropChange};

/// Compute diff between two HTML documents and return patches as JSON.
/// This allows computing diffs in the browser for fuzzing tests.
#[wasm_bindgen]
pub fn diff_html(old_html: &str, new_html: &str) -> Result<String, JsValue> {
    let patches = hotmeal::diff_html(old_html, new_html)
        .map_err(|e| JsValue::from_str(&format!("diff failed: {e}")))?;

    let json = facet_json::to_string(&patches)
        .map_err(|e| JsValue::from_str(&format!("serialize failed: {e}")))?;

    Ok(json)
}

/// Slots for detached nodes during patch application.
/// In Chawathe's model, INSERT doesn't shift - it displaces the occupant to a slot.
struct Slots {
    nodes: Vec<Option<Node>>,
}

impl Slots {
    fn new() -> Self {
        Self { nodes: Vec::new() }
    }

    fn store(&mut self, slot: u32, node: Node) {
        let idx = slot as usize;
        if idx >= self.nodes.len() {
            self.nodes.resize(idx + 1, None);
        }
        self.nodes[idx] = Some(node);
    }

    fn take(&mut self, slot: u32) -> Option<Node> {
        let idx = slot as usize;
        if idx < self.nodes.len() {
            self.nodes[idx].take()
        } else {
            None
        }
    }

    fn get(&self, slot: u32) -> Option<&Node> {
        let idx = slot as usize;
        self.nodes.get(idx).and_then(|n| n.as_ref())
    }
}

/// Apply a list of patches to the current document.
/// Returns the number of patches applied, or an error message.
#[wasm_bindgen]
pub fn apply_patches_json(patches_json: &str) -> Result<usize, JsValue> {
    let patches: Vec<Patch> = facet_json::from_str(patches_json)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse patches: {e}")))?;

    apply_patches(&patches)
}

/// Apply patches to the document.
pub fn apply_patches(patches: &[Patch]) -> Result<usize, JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;

    let count = patches.len();
    log(&format!("[hotmeal-wasm] applying {} patches", count));

    let mut slots = Slots::new();

    for (i, patch) in patches.iter().enumerate() {
        log(&format!("[hotmeal-wasm] patch {}: {:?}", i, patch));
        apply_patch(&document, patch, &mut slots)?;
    }

    Ok(count)
}

fn apply_patch(doc: &Document, patch: &Patch, slots: &mut Slots) -> Result<(), JsValue> {
    debug!(?patch, "applying patch");
    match patch {
        Patch::SetText { path, text } => {
            let node = find_node(doc, path, slots)?;
            node.set_text_content(Some(text));
        }

        Patch::SetAttribute { path, name, value } => {
            let el = find_element(doc, path, slots)?;
            // Convert QualName to attribute name string
            let attr_name = if let Some(ref prefix) = name.prefix {
                format!("{}:{}", prefix, name.local)
            } else {
                name.local.to_string()
            };
            el.set_attribute(&attr_name, value)?;
        }

        Patch::RemoveAttribute { path, name } => {
            let el = find_element(doc, path, slots)?;
            // Convert QualName to attribute name string
            let attr_name = if let Some(ref prefix) = name.prefix {
                format!("{}:{}", prefix, name.local)
            } else {
                name.local.to_string()
            };
            el.remove_attribute(&attr_name)?;
        }

        Patch::Remove { node } => {
            match node {
                NodeRef::Path(path) => {
                    // Replace with empty text node (no shifting - Chawathe semantics)
                    let target = find_node(doc, path, slots)?;
                    if let Some(parent) = target.parent_node() {
                        let empty_text = doc.create_text_node("");
                        parent.replace_child(&empty_text, &target)?;
                    }
                }
                NodeRef::Slot(s, _) => {
                    // Just remove from slots - the node was already detached
                    slots.take(*s);
                }
            }
        }

        Patch::InsertElement {
            at,
            tag,
            attrs,
            children,
            detach_to_slot,
        } => {
            // Extract parent and position from NodeRef
            let (parent_el, position) = match at {
                NodeRef::Path(path) => {
                    if path.0.is_empty() {
                        return Err(JsValue::from_str("InsertElement: empty path"));
                    }
                    let parent_path = NodePath(path.0[..path.0.len() - 1].to_vec());
                    let position = path.0[path.0.len() - 1];
                    let parent_node = if parent_path.0.is_empty() {
                        let body = doc.body().ok_or_else(|| JsValue::from_str("no body"))?;
                        body.into()
                    } else {
                        find_node(doc, &parent_path, slots)?
                    };
                    let parent_el = parent_node
                        .dyn_ref::<Element>()
                        .ok_or_else(|| JsValue::from_str("parent is not an element"))?
                        .clone();
                    (parent_el, position)
                }
                NodeRef::Slot(slot, rel_path) => {
                    let slot_root = slots
                        .get(*slot)
                        .cloned()
                        .ok_or_else(|| JsValue::from_str(&format!("slot {} is empty", slot)))?;

                    let rel_path = rel_path.as_ref().ok_or_else(|| {
                        JsValue::from_str("InsertElement: slot reference without relative path")
                    })?;

                    if rel_path.0.is_empty() {
                        return Err(JsValue::from_str("InsertElement: empty relative path"));
                    }

                    let parent_path_in_slot = if rel_path.0.len() > 1 {
                        Some(NodePath(rel_path.0[..rel_path.0.len() - 1].to_vec()))
                    } else {
                        None
                    };
                    let position = rel_path.0[rel_path.0.len() - 1];

                    let parent_node = if let Some(p) = parent_path_in_slot {
                        navigate_within_node(&slot_root, &p)?
                    } else {
                        slot_root
                    };

                    let parent_el = parent_node
                        .dyn_ref::<Element>()
                        .ok_or_else(|| JsValue::from_str("slot parent is not an element"))?
                        .clone();
                    (parent_el, position)
                }
            };

            // Create the new element
            let new_el = doc.create_element(tag)?;

            // Set attributes
            for attr in attrs {
                // Convert QualName to attribute name string
                let attr_name = if let Some(ref prefix) = attr.name.prefix {
                    format!("{}:{}", prefix, attr.name.local)
                } else {
                    attr.name.local.to_string()
                };
                new_el.set_attribute(&attr_name, &attr.value)?;
            }

            // Add children
            for child in children {
                let child_node = create_insert_content(doc, child)?;
                new_el.append_child(&child_node)?;
            }

            // Insert at position with Chawathe displacement semantics
            insert_at_position(
                doc,
                &parent_el,
                &new_el.into(),
                position,
                *detach_to_slot,
                slots,
            )?;
        }

        Patch::InsertText {
            at,
            text,
            detach_to_slot,
        } => {
            // Extract parent and position from NodeRef
            let (parent_el, position) = match at {
                NodeRef::Path(path) => {
                    if path.0.is_empty() {
                        return Err(JsValue::from_str("InsertText: empty path"));
                    }
                    let parent_path = NodePath(path.0[..path.0.len() - 1].to_vec());
                    let position = path.0[path.0.len() - 1];
                    let parent_node = if parent_path.0.is_empty() {
                        let body = doc.body().ok_or_else(|| JsValue::from_str("no body"))?;
                        body.into()
                    } else {
                        find_node(doc, &parent_path, slots)?
                    };
                    let parent_el = parent_node
                        .dyn_ref::<Element>()
                        .ok_or_else(|| JsValue::from_str("parent is not an element"))?
                        .clone();
                    (parent_el, position)
                }
                NodeRef::Slot(slot, rel_path) => {
                    let slot_root = slots
                        .get(*slot)
                        .cloned()
                        .ok_or_else(|| JsValue::from_str(&format!("slot {} is empty", slot)))?;

                    let rel_path = rel_path.as_ref().ok_or_else(|| {
                        JsValue::from_str("InsertText: slot reference without relative path")
                    })?;

                    if rel_path.0.is_empty() {
                        return Err(JsValue::from_str("InsertText: empty relative path"));
                    }

                    let parent_path_in_slot = if rel_path.0.len() > 1 {
                        Some(NodePath(rel_path.0[..rel_path.0.len() - 1].to_vec()))
                    } else {
                        None
                    };
                    let position = rel_path.0[rel_path.0.len() - 1];

                    let parent_node = if let Some(p) = parent_path_in_slot {
                        navigate_within_node(&slot_root, &p)?
                    } else {
                        slot_root
                    };

                    let parent_el = parent_node
                        .dyn_ref::<Element>()
                        .ok_or_else(|| JsValue::from_str("slot parent is not an element"))?
                        .clone();
                    (parent_el, position)
                }
            };

            // Create text node
            let text_node = doc.create_text_node(text);

            // Insert at position with Chawathe displacement semantics
            insert_at_position(
                doc,
                &parent_el,
                &text_node.into(),
                position,
                *detach_to_slot,
                slots,
            )?;
        }

        Patch::InsertComment {
            at,
            text,
            detach_to_slot,
        } => {
            // Extract parent and position from NodeRef
            let (parent_el, position) = match at {
                NodeRef::Path(path) => {
                    if path.0.is_empty() {
                        return Err(JsValue::from_str("InsertComment: empty path"));
                    }
                    let parent_path = NodePath(path.0[..path.0.len() - 1].to_vec());
                    let position = path.0[path.0.len() - 1];
                    let parent_node = if parent_path.0.is_empty() {
                        let body = doc.body().ok_or_else(|| JsValue::from_str("no body"))?;
                        body.into()
                    } else {
                        find_node(doc, &parent_path, slots)?
                    };
                    let parent_el = parent_node
                        .dyn_ref::<Element>()
                        .ok_or_else(|| JsValue::from_str("parent is not an element"))?
                        .clone();
                    (parent_el, position)
                }
                NodeRef::Slot(slot, rel_path) => {
                    let slot_root = slots
                        .get(*slot)
                        .cloned()
                        .ok_or_else(|| JsValue::from_str(&format!("slot {} is empty", slot)))?;

                    let rel_path = rel_path.as_ref().ok_or_else(|| {
                        JsValue::from_str("InsertComment: slot reference without relative path")
                    })?;

                    if rel_path.0.is_empty() {
                        return Err(JsValue::from_str("InsertComment: empty relative path"));
                    }

                    let parent_path_in_slot = if rel_path.0.len() > 1 {
                        Some(NodePath(rel_path.0[..rel_path.0.len() - 1].to_vec()))
                    } else {
                        None
                    };
                    let position = rel_path.0[rel_path.0.len() - 1];

                    let parent_node = if let Some(p) = parent_path_in_slot {
                        navigate_within_node(&slot_root, &p)?
                    } else {
                        slot_root
                    };

                    let parent_el = parent_node
                        .dyn_ref::<Element>()
                        .ok_or_else(|| JsValue::from_str("slot parent is not an element"))?
                        .clone();
                    (parent_el, position)
                }
            };

            // Create comment node
            let comment_node = doc.create_comment(text);

            // Insert at position with Chawathe displacement semantics
            insert_at_position(
                doc,
                &parent_el,
                &comment_node.into(),
                position,
                *detach_to_slot,
                slots,
            )?;
        }

        Patch::UpdateProps { path, changes } => {
            let node = find_node(doc, path, slots)?;

            // Handle text content updates
            if let Some(text_change) = changes.iter().find(|c| matches!(c.name, PropKey::Text))
                && let Some(v) = &text_change.value
            {
                node.set_text_content(Some(v));
            }
            // None means keep existing - do nothing

            // Handle element attribute updates
            // The changes vec represents the ENTIRE final attribute state
            if let Some(el) = node.dyn_ref::<Element>() {
                // Collect attribute names in changes (excluding Text)
                let final_attrs: std::collections::HashSet<String> = changes
                    .iter()
                    .filter_map(|c| {
                        if let PropKey::Attr(ref qual_name) = c.name {
                            Some(if let Some(ref prefix) = qual_name.prefix {
                                format!("{}:{}", prefix, qual_name.local)
                            } else {
                                qual_name.local.to_string()
                            })
                        } else {
                            None
                        }
                    })
                    .collect();

                // Remove attributes not in final state
                let current_attrs: Vec<String> = (0..el.attributes().length())
                    .filter_map(|i| el.attributes().item(i).map(|a| a.name()))
                    .collect();

                for attr_name in current_attrs {
                    if !final_attrs.contains(&attr_name) {
                        el.remove_attribute(&attr_name)?;
                    }
                }

                // Set attributes from changes
                for change in changes {
                    if let PropKey::Attr(ref qual_name) = change.name
                        && let Some(new_value) = &change.value
                    {
                        // Different value - update it
                        let attr_name = if let Some(ref prefix) = qual_name.prefix {
                            format!("{}:{}", prefix, qual_name.local)
                        } else {
                            qual_name.local.to_string()
                        };
                        el.set_attribute(&attr_name, new_value.as_ref())?;
                    }
                    // None means keep existing - do nothing (attribute already exists)
                }
            }
        }

        Patch::Move {
            from,
            to,
            detach_to_slot,
        } => {
            // Get the node to move (from path or slot)
            let node = match from {
                NodeRef::Path(path) => {
                    let node = find_node(doc, path, slots)?;
                    // Replace with empty text node (no shifting - Chawathe semantics)
                    if let Some(parent) = node.parent_node() {
                        let empty_text = doc.create_text_node("");
                        parent.replace_child(&empty_text, &node)?;
                    }
                    node
                }
                NodeRef::Slot(slot, rel_path) => {
                    if let Some(path) = rel_path {
                        // Moving a child within the slot - don't consume the slot
                        let slot_root = slots
                            .get(*slot)
                            .ok_or_else(|| JsValue::from_str(&format!("slot {} is empty", slot)))?;
                        let node = navigate_within_node(slot_root, path)?;
                        // Detach from parent with placeholder (Chawathe semantics)
                        if let Some(parent) = node.parent_node() {
                            let empty_text = doc.create_text_node("");
                            parent.replace_child(&empty_text, &node)?;
                        }
                        node
                    } else {
                        // Moving the entire slot root - consume the slot
                        slots
                            .take(*slot)
                            .ok_or_else(|| JsValue::from_str(&format!("slot {} is empty", slot)))?
                    }
                }
            };

            // Find the parent and position from the target
            match to {
                NodeRef::Path(path) => {
                    if path.0.is_empty() {
                        return Err(JsValue::from_str("Move: cannot move to root"));
                    }
                    let parent_path = NodePath(path.0[..path.0.len() - 1].to_vec());
                    let target_idx = path.0[path.0.len() - 1];

                    let parent_node = find_node(doc, &parent_path, slots)?;
                    let parent_el = parent_node
                        .dyn_ref::<Element>()
                        .ok_or_else(|| JsValue::from_str("parent is not an element"))?;

                    // Insert at the target position with Chawathe displacement
                    insert_at_position(doc, parent_el, &node, target_idx, *detach_to_slot, slots)?;
                }
                NodeRef::Slot(slot, rel_path) => {
                    // Moving into a slot - get the slot root and navigate
                    let slot_root = slots.get(*slot).ok_or_else(|| {
                        JsValue::from_str(&format!("target slot {} is empty", slot))
                    })?;

                    let (parent_el, target_idx) = if let Some(path) = rel_path {
                        if path.0.is_empty() {
                            return Err(JsValue::from_str("Move: cannot move to slot root"));
                        }
                        let parent_path = NodePath(path.0[..path.0.len() - 1].to_vec());
                        let target_idx = path.0[path.0.len() - 1];
                        let parent_node = navigate_within_node(slot_root, &parent_path)?;
                        let parent_el = parent_node
                            .dyn_ref::<Element>()
                            .ok_or_else(|| JsValue::from_str("slot parent is not an element"))?
                            .clone();
                        (parent_el, target_idx)
                    } else {
                        return Err(JsValue::from_str(
                            "Move: cannot move to slot root without relative path",
                        ));
                    };

                    insert_at_position(doc, &parent_el, &node, target_idx, *detach_to_slot, slots)?;
                }
            }
        }
    }

    Ok(())
}

/// Insert a node at a position within a parent, using Chawathe displacement semantics.
/// If there's a node at the position, it gets replaced (and optionally stored in a slot).
fn insert_at_position(
    doc: &Document,
    parent: &Element,
    node: &Node,
    position: usize,
    detach_to_slot: Option<u32>,
    slots: &mut Slots,
) -> Result<(), JsValue> {
    let children = parent.child_nodes();
    let current_len = children.length() as usize;
    let pos = position as u32;

    trace!(
        parent_tag = parent.tag_name(),
        position,
        current_len,
        ?detach_to_slot,
        "insert_at_position"
    );

    if position < current_len {
        // Position exists - replace (Chawathe semantics - no shift)
        let existing = children.item(pos).unwrap();
        trace!(
            existing_node_type = existing.node_type(),
            existing_text = ?existing.text_content(),
            "replacing existing node"
        );
        let replaced = parent.replace_child(node, &existing)?;
        if let Some(slot) = detach_to_slot {
            trace!(slot, "storing replaced node in slot");
            slots.store(slot, replaced);
        }
    } else {
        // Position is beyond current children - grow with empty text placeholders
        trace!(
            growing_from = current_len,
            growing_to = position,
            "growing with placeholders"
        );
        for _ in current_len..position {
            let placeholder = doc.create_text_node("");
            parent.append_child(&placeholder)?;
        }
        parent.append_child(node)?;
    }

    Ok(())
}

/// Create a DOM node from InsertContent.
fn create_insert_content(doc: &Document, content: &InsertContent) -> Result<Node, JsValue> {
    match content {
        InsertContent::Element {
            tag,
            attrs,
            children,
        } => {
            let el = doc.create_element(tag)?;
            for attr in attrs {
                // Convert QualName to attribute name string
                let attr_name = if let Some(ref prefix) = attr.name.prefix {
                    format!("{}:{}", prefix, attr.name.local)
                } else {
                    attr.name.local.to_string()
                };
                el.set_attribute(&attr_name, &attr.value)?;
            }
            for child in children {
                let child_node = create_insert_content(doc, child)?;
                el.append_child(&child_node)?;
            }
            Ok(el.into())
        }
        InsertContent::Text(text) => Ok(doc.create_text_node(text).into()),
        InsertContent::Comment(text) => Ok(doc.create_comment(text).into()),
    }
}

/// Navigate a relative path within a node (for slot-relative paths).
fn navigate_within_node(root: &Node, path: &NodePath) -> Result<Node, JsValue> {
    let mut current = root.clone();
    for &idx in &path.0 {
        let children = current.child_nodes();
        current = children
            .item(idx as u32)
            .ok_or_else(|| JsValue::from_str(&format!("relative path child {} not found", idx)))?;
    }
    Ok(current)
}

/// Find a node by DOM path.
fn find_node(doc: &Document, path: &NodePath, _slots: &Slots) -> Result<Node, JsValue> {
    let body = doc.body().ok_or_else(|| JsValue::from_str("no body"))?;
    let mut current: Node = body.into();

    trace!(?path, "find_node starting from body");

    for &idx in &path.0 {
        let children = current.child_nodes();
        let num_children = children.length();
        trace!(idx, num_children, "navigating to child");
        current = children.item(idx as u32).ok_or_else(|| {
            JsValue::from_str(&format!(
                "child {} not found (parent has {} children)",
                idx, num_children
            ))
        })?;
        trace!(
            node_type = current.node_type(),
            node_name = current.node_name(),
            "found node"
        );
    }

    Ok(current)
}

/// Find an element by DOM path.
fn find_element(doc: &Document, path: &NodePath, slots: &Slots) -> Result<Element, JsValue> {
    let node = find_node(doc, path, slots)?;
    node.dyn_into::<Element>()
        .map_err(|_| JsValue::from_str("node is not an element"))
}

/// Log a message to the browser console.
#[wasm_bindgen]
pub fn log(msg: &str) {
    web_sys::console::log_1(&JsValue::from_str(msg));
}

/// Get the innerHTML of the body element.
#[wasm_bindgen]
pub fn get_body_inner_html() -> Result<String, JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;
    let body = document
        .body()
        .ok_or_else(|| JsValue::from_str("no body"))?;

    Ok(body.inner_html())
}

/// Set the innerHTML of the body element.
#[wasm_bindgen]
pub fn set_body_inner_html(html: &str) -> Result<(), JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;
    let body = document
        .body()
        .ok_or_else(|| JsValue::from_str("no body"))?;

    body.set_inner_html(html);
    Ok(())
}

/// Dump the browser DOM structure as a string (for debugging).
#[wasm_bindgen]
pub fn dump_browser_dom() -> Result<String, JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;
    let body = document
        .body()
        .ok_or_else(|| JsValue::from_str("no body"))?;

    fn dump_node(node: &Node, indent: usize) -> String {
        let prefix = "  ".repeat(indent);
        let mut result = String::new();

        let node_type = node.node_type();
        match node_type {
            Node::ELEMENT_NODE => {
                let tag = node.node_name();
                result.push_str(&format!("{}Element({})\n", prefix, tag));
            }
            Node::TEXT_NODE => {
                let text = node.text_content().unwrap_or_default();
                let escaped = text.replace('\n', "\\n").replace(' ', "·");
                result.push_str(&format!("{}Text({:?})\n", prefix, escaped));
            }
            _ => {
                result.push_str(&format!("{}Node(type={})\n", prefix, node_type));
            }
        }

        let children = node.child_nodes();
        for i in 0..children.length() {
            if let Some(child) = children.get(i) {
                result.push_str(&dump_node(&child, indent + 1));
            }
        }
        result
    }

    Ok(dump_node(&body.into(), 0))
}

/// Dump the Rust-parsed HTML structure as a string (for debugging).
/// Uses arena_dom which is what diff_html uses.
#[wasm_bindgen]
pub fn dump_rust_parsed(html: &str) -> Result<String, JsValue> {
    use hotmeal::{self, NodeKind};

    let full_html = format!("<html><body>{}</body></html>", html);
    let doc = parse(&full_html);

    fn dump_node(doc: &hotmeal::Document, node_id: NodeId, indent: usize) -> String {
        let prefix = "  ".repeat(indent);
        let node = doc.get(node_id);
        let mut result = match &node.kind {
            NodeKind::Document => format!("{}Document\n", prefix),
            NodeKind::Element(elem) => {
                format!("{}Element({})\n", prefix, elem.tag.as_ref().to_uppercase())
            }
            NodeKind::Text(t) => {
                let escaped = t.as_ref().replace('\n', "\\n").replace(' ', "·");
                format!("{}Text({:?})\n", prefix, escaped)
            }
            NodeKind::Comment(c) => {
                format!("{}Comment({:?})\n", prefix, c.as_ref())
            }
        };
        for child_id in node_id.children(&doc.arena) {
            result.push_str(&dump_node(doc, child_id, indent + 1));
        }
        result
    }

    // Find the body element to match the browser DOM dump behavior
    fn find_body(doc: &hotmeal::Document, node_id: NodeId) -> Option<NodeId> {
        let node = doc.get(node_id);
        if let NodeKind::Element(elem) = &node.kind
            && elem.tag.as_ref().eq_ignore_ascii_case("body")
        {
            return Some(node_id);
        }
        for child_id in node_id.children(&doc.arena) {
            if let Some(body_id) = find_body(doc, child_id) {
                return Some(body_id);
            }
        }
        None
    }

    let body_id = find_body(&doc, doc.root)
        .ok_or_else(|| JsValue::from_str("body element not found in parsed HTML"))?;

    Ok(dump_node(&doc, body_id, 0))
}
