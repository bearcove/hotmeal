# Handoff: Fuzzing and Bug Fixes

## Completed
- Fixed Move from Slot with relative path in `hotmeal/src/diff/apply.rs:408-438`
- Fixed duplicate nodes by tracking Insert ops in `hotmeal/src/diff/tree.rs:588-601`
- Fixed Move to unmatched parent in `cinereus/src/chawathe.rs:228-230`
- Fixed simplification parent-child checking in `cinereus/src/simplify.rs` (now deleted)
- Fixed shadow tree position preservation in `hotmeal/src/diff/tree.rs:489-519`
- Removed all simplification code from cinereus
- Added fuzzer test cases in `hotmeal/src/diff/tree.rs:983-1145`
- Added DEVELOP.md with fuzzing workflow
- Commits: 42cc837, 0d7bae1, f4e7e8b, 34a376c

## Active Work

### Origin
User said:
> "keep going"

After we fixed multiple fuzzing bugs, the user ran fuzzer again and it found a new crash:
```
"Move: slot contains text, cannot navigate to child"
```

Then user said:
> "let's fix that"

### The Problem
The fuzzer found a case where we're trying to do `Move from Slot(0, Some(NodePath([4, 0, 0, 0])))` but when we navigate into the slot to extract the child, we hit a text node instead of an element.

The error occurs in `hotmeal/src/diff/apply.rs:435-436`:
```rust
Content::Text(_) => {
    return Err("Move: slot contains text, cannot navigate to child".to_string());
}
```

### Current State
- Branch: `opts`
- Last commit: `34a376c` - "remove: delete simplification code entirely"
- All 35 tests passing (including 34 before + the new one I added)
- Fuzzer crash artifact: `hotmeal/fuzz/artifacts/roundtrip/crash-6d768df498c1d9eb87f10af333dbfa661c68da33`

**What's done:**
- Created test case `test_fuzzer_article_code_move` in `hotmeal/src/diff/tree.rs:1123-1145`
- Test HTML uses unescaped `<` characters (fuzzer generates these, html5ever parses as elements)

**What's NOT done:**
- The test probably doesn't reproduce the exact bug yet (needs verification)
- The root cause hasn't been identified
- No fix implemented

### Technical Context

**The Fuzzer Input:**
```rust
old: [
    Article {
        children: [
            Code { text: "<" }, Code { text: "<" }, Code { text: "<" }, Code { text: "<" },
            Article {
                children: [
                    Article {
                        children: [
                            Code { text: "<" },
                            Text(""),
                        ],
                    },
                    Text(""),
                ],
            },
        ],
    },
],
new: [
    Code { text: "<" }, Code { text: "<" }, Code { text: "<" }, Code { text: "<" },
    Article {
        children: [
            Code { text: "<" }, Code { text: "<" },
            H2 { text: "<<<<<<<<<<<<<" },
            Text(""), Text(""),
        ],
    },
]
```

**How to reproduce:**
```bash
cd hotmeal/fuzz
cargo +nightly fuzz run roundtrip artifacts/roundtrip/crash-6d768df498c1d9eb87f10af333dbfa661c68da33
```

**The Move Operation Logic:**
When moving from a slot with a relative path like `Slot(0, Some(NodePath([4, 0, 0, 0])))`:
1. Get slot 0 content
2. Navigate path `[4, 0, 0, 0]` - go to child 4, then child 0, then child 0, then child 0
3. At some point in this navigation, we hit a Text node instead of an Element
4. Can't navigate through text â†’ error

**Why This Happens:**
The shadow tree's structure diverges from what cinereus expects. During patch application, nodes get moved/removed/inserted, and the relative paths that were computed during diff generation become invalid.

**Possible Root Causes:**
1. **Cinereus bug**: The relative path is wrong because cinereus computed it from a different tree state
2. **Shadow tree bug**: Our shadow tree operations don't preserve structure correctly
3. **Patch ordering bug**: Operations are applied in wrong order, invalidating later paths

**Key Code Locations:**

`hotmeal/src/diff/apply.rs:408-438` - Move from Slot logic:
```rust
NodeRef::Slot(slot, relative_path) => {
    if let Some(rel_path) = relative_path {
        // Moving a child from within the slotted content
        let slot_content = slots.get_mut(slot)...;
        match slot_content {
            Content::Element(e) => {
                let children = navigate_to_children_in_slot(e, Some(rel_path))?;
                let from_idx = rel_path.0[rel_path.0.len() - 1];
                // Extract the child
                std::mem::replace(&mut children[from_idx], Content::Text(String::new()))
            }
            Content::Text(_) => {
                return Err("Move: slot contains text, cannot navigate to child".to_string());
            }
        }
    }
```

`hotmeal/src/diff/apply.rs:253-278` - `navigate_to_children_in_slot` helper:
```rust
fn navigate_to_children_in_slot(
    elem: &mut Element,
    path: Option<&NodePath>,
) -> Result<&mut Vec<Content>, String> {
    let mut current = elem;
    let nav_path = if let Some(p) = path {
        &p.0[..p.0.len() - 1]  // All but last element
    } else {
        &[]
    };
    for &idx in nav_path {
        let child = current.children.get_mut(idx)...;
        current = match child {
            Content::Element(e) => e,
            Content::Text(_) => {
                return Err("cannot navigate through text node".to_string());
            }
        };
    }
    Ok(&mut current.children)
}
```

**Shadow Tree Context:**
`hotmeal/src/diff/tree.rs:284-430` - ShadowTree implementation
- `get_node_ref()` - computes NodeRef (Path or Slot) for shadow tree nodes
- `compute_path()` - computes path from root to node
- `find_detached_ancestor()` - finds if node or ancestor is detached
- Operations update shadow tree structure which affects future path computations

### Success Criteria
1. `test_fuzzer_article_code_move` passes
2. Fuzzer runs for 3 minutes with no crashes
3. All existing 34 tests still pass
4. Root cause is understood and documented in test comment
5. Fix is minimal and doesn't break existing functionality

### Files to Touch
- `hotmeal/src/diff/apply.rs:253-278` - `navigate_to_children_in_slot` (maybe needs better error handling or path validation)
- `hotmeal/src/diff/apply.rs:408-438` - Move from Slot logic (may need to handle edge cases)
- `hotmeal/src/diff/tree.rs:284-430` - ShadowTree methods (if path computation is wrong)
- `hotmeal/src/diff/tree.rs:1123-1145` - The test case (may need adjustment to actually reproduce bug)
- Possibly `cinereus/src/chawathe.rs` if the relative path computation is fundamentally wrong

### Decisions Made
- **Removed simplification entirely** - User said "let's delete simplification code now. we might tackle it again later from scratch."
- **Use fuzzer-generated HTML directly** - Tests use unescaped `<` characters like the fuzzer generates, so html5ever parses them as elements
- **Keep fuzzing** - User wants to continue finding and fixing bugs through fuzzing

### What NOT to Do
- Don't re-implement simplification
- Don't skip fuzzer artifacts (they're in `.gitignore` anyway)
- Don't over-engineer the fix - find the specific case that's broken and fix just that

### Blockers/Gotchas
- **The test might not actually reproduce the bug yet** - I created it from the fuzzer's `Debug` output but didn't verify it fails with the same error
- **Fuzzer needs nightly Rust** - `cargo +nightly fuzz run roundtrip`
- **html5ever parsing** - Unescaped `<` in text creates elements, which is weird but intentional (fuzzer feature)
- **Slot navigation is complex** - relative paths are computed during diff but applied later when tree structure has changed
- **Previous similar issues**:
  - "Insert: cannot navigate through text node" - fixed by growing children array with placeholders (commit f4e7e8b)
  - "Move from Slot" not extracting child correctly - fixed by navigating to relative path (commit 42cc837)

### Debug Strategy
1. First verify the test actually reproduces the error:
   ```bash
   cd hotmeal
   cargo test --lib test_fuzzer_article_code_move 2>&1 | grep "slot contains text"
   ```
2. If not, run the actual fuzzer input and extract the exact HTML
3. Add debug output in `navigate_to_children_in_slot` to see what path is being traversed
4. Compare the slot structure at Move time vs what cinereus expected
5. Likely need to handle case where a text node ends up where cinereus expected an element

### Previous Fuzzing Fixes (Context)
We fixed 5 major bugs through fuzzing:
1. **Move from Slot with relative path** - wasn't navigating to child, took entire slot
2. **Duplicate nodes** - extract_content included matched children that should be moved separately
3. **Move to unmatched parent** - cinereus was skipping these moves
4. **Simplification parent-child** - only checked tree_b, needed to check both trees
5. **Position preservation** - insert_at_position didn't grow array with placeholders

Pattern: Most bugs involve mismatches between cinereus expectations and shadow tree reality during patch application.

## Bootstrap
```bash
cd /Users/amos/bearcove/hotmeal

# Check current state
git status
git log --oneline -5

# Run the test to see if it reproduces the bug
cargo test --lib test_fuzzer_article_code_move -- --nocapture

# If test doesn't fail, run actual fuzzer artifact
cd hotmeal/fuzz
cargo +nightly fuzz run roundtrip artifacts/roundtrip/crash-6d768df498c1d9eb87f10af333dbfa661c68da33

# After fixing, verify with fuzzer
cargo +nightly fuzz run roundtrip -- -max_total_time=180
```
