# Handoff: SmallVec Path Optimization

## Completed
- Implemented `DiffTree` trait in cinereus for flexible tree diffing
- Updated matching/chawathe to accept two different generic tree types (`<TA, TB>` where `TB: DiffTree<Types = TA::Types>`)
- Created `DiffableDocument` wrapper in `hotmeal/src/diff.rs` that implements `DiffTree` for `Document`
- Updated `diff()` to use `DiffableDocument` for tree_b (avoids one tree allocation)
- Closed issue #11 (tree unification)
- Removed unused `indexmap` dependency (caught by pre-push hook)

## Active Work

### Origin
User asked to tackle GitHub issues from https://github.com/bearcove/hotmeal/issues

I picked issue #10: Cache/optimize path computation with SmallVec
https://github.com/bearcove/hotmeal/issues/10

From profiling XXL benchmark (492KB HTML):
> "21% in ShadowTree::compute_path"

### The Problem
`ShadowTree::compute_path` in `hotmeal/src/diff.rs` is called repeatedly during `convert_ops_with_shadow`. Each call walks from a node up to the root building a `Vec<usize>` path. This allocates heap memory for every path, even though most paths are short (<16 elements).

### Current State
- Branch: `smallvec-paths` (just created, no commits yet)
- Issue: #10 (https://github.com/bearcove/hotmeal/issues/10)
- PR: not created yet

Just started this work - only created the branch. Haven't added smallvec dependency yet.

### Technical Context

The path types in `hotmeal/src/diff.rs`:
```rust
// Line ~148
#[derive(Debug, Clone, PartialEq, Eq, Hash, facet::Facet)]
#[facet(transparent)]
pub struct NodePath(pub Vec<usize>);

// Line ~172
#[derive(Debug, Clone, PartialEq, Eq, facet::Facet)]
#[facet(transparent)]
pub struct NodeRef(pub NodePath);
```

The hot path is `ShadowTree::compute_path` around line 636:
```rust
fn compute_path(&self, node: NodeId) -> Vec<usize> {
    let mut path = Vec::new();
    // ... walks up tree adding positions
    path.reverse();
    path
}
```

And `get_node_ref_with_position` around line 676:
```rust
fn get_node_ref_with_position(&self, parent: NodeId, position: usize) -> NodeRef {
    let mut path = self.compute_path(parent);
    path.push(position);
    NodeRef(NodePath(path))
}
```

### Success Criteria
1. Add `smallvec = "1"` to `hotmeal/Cargo.toml` dependencies
2. Change `NodePath` to use `SmallVec<[usize; 16]>` instead of `Vec<usize>`
3. Update all path construction to use `SmallVec`
4. All tests pass (`cargo nextest run -p hotmeal`)
5. Benchmark shows improvement on XXL (`cargo bench -p hotmeal --bench full_cycle`)
6. Close issue #10 with PR

### Files to Touch
- `hotmeal/Cargo.toml` - add `smallvec = "1"` to dependencies
- `hotmeal/src/diff.rs`:
  - Line ~148: Change `NodePath(pub Vec<usize>)` to `NodePath(pub SmallVec<[usize; 16]>)`
  - Line ~636: `compute_path` - change return type and `Vec::new()` to `SmallVec::new()`
  - Line ~676: `get_node_ref_with_position` - uses `compute_path`, should work automatically
  - All places that construct paths or call `.0` on NodePath

Note: `facet::Facet` derive on `NodePath` - need to check if facet supports SmallVec. If not, may need `#[facet(transparent)]` to work differently or use a proxy.

### Decisions Made
- Chose size 16 for SmallVec because DOM paths are typically short (most elements are <10 levels deep)
- Tackling #10 before #9 (position caching) because SmallVec is simpler and has big impact

### What NOT to Do
- Don't change the `Patch` serialization format - paths still need to serialize as arrays of usize
- Don't tackle position caching (#9) in this PR - separate issue

### Blockers/Gotchas
- `facet::Facet` derive might not support SmallVec directly - may need a proxy type or `#[facet(transparent)]`
- SmallVec needs `use smallvec::{SmallVec, smallvec}` import
- The `reverse()` call in `compute_path` works on SmallVec too

## Bootstrap
```bash
git status  # should be on smallvec-paths branch with no changes
cargo check -p hotmeal  # verify current state compiles
# Then add smallvec dep and update NodePath type
```
